package com.nelkinda.rel

import com.nelkinda.kotlin.getClassPath
import com.nelkinda.kotlin.toHexString
import java.io.File
import java.io.FileOutputStream
import java.net.URL
import java.net.URLClassLoader
import java.nio.file.Path
import java.security.MessageDigest
import java.util.jar.JarFile
import kotlin.io.path.writeText
import kotlin.reflect.KClass
import kotlin.reflect.full.createInstance

fun sha256Hex(input: String) = MessageDigest.getInstance("sha256").digest(input.toByteArray()).toHexString()

abstract class ExpressionCompilerImpl(
    protected val outputDirectory: File,
    private val suffix: String,
) : ExpressionCompiler {
    val loader = URLClassLoader(
        arrayOf(outputDirectory.toURI().toURL()),
        this::class.java.classLoader
    )

    @SuppressWarnings("TooGenericExceptionCaught", "SwallowedException")
    protected val libraryClassPath = getClassPath().run {
        try {
            val cp = URL(this).path
            System.err.println(cp)
            val (jar1, jar2) = cp.split("!/")
            JarFile(jar1).use { jarFile ->
                FileOutputStream(File(jar2).name).use { out ->
                    val jarEntry = jarFile.getJarEntry(jar2)
                    jarFile.getInputStream(jarEntry).transferTo(out)
                }
            }
            File(jar2).name
        } catch (e: Exception) {
            this
        }
    }

    @Suppress("UNCHECKED_CAST")
    inline fun <reified T> createInstance(className: String): T =
        loader.loadClass(className).kotlin.createInstance() as T

    @SuppressWarnings("SwallowedException")
    override fun <In : Any, Out : Any> compile(
        expression: String,
        inClass: KClass<In>,
        outClass: KClass<Out>,
    ) = try {
        createInstance(autoGeneratedClassName(expression, inClass, outClass))
    } catch (e: ClassNotFoundException) {
        compileAndCreateInstance(expression, autoGeneratedClassName(expression, inClass, outClass), inClass, outClass)
    }

    private fun <In : Any, Out : Any> compileAndCreateInstance(
        expression: String,
        className: String,
        inClass: KClass<In>,
        outClass: KClass<Out>,
    ): Function<In, Out> {
        compile(createSourceFile(expression, className, inClass, outClass))
        return createInstance(className)
    }

    fun <In : Any, Out : Any> createSourceFile(
        expression: String,
        className: String,
        inClass: KClass<In>,
        outClass: KClass<Out>,
    ): Path = File(outputDirectory, "$className$suffix").toPath().apply {
        writeText(generateExpressionSourceCode(expression, className, inClass, outClass))
    }

    abstract fun <In : Any, Out : Any> generateExpressionSourceCode(
        expression: String,
        className: String,
        inClass: KClass<In>,
        outClass: KClass<Out>,
    ): String

    protected abstract fun compile(input: Path)

    fun <In : Any, Out : Any> autoGeneratedClassName(
        expression: String,
        inClass: KClass<In>,
        outClass: KClass<Out>,
    ): String {
        val className = "Expression${sha256Hex(expression + inClass.simpleName + outClass.simpleName)}"
        return "Expression${sha256Hex(generateExpressionSourceCode(expression, className, inClass, outClass))}"
    }
}
